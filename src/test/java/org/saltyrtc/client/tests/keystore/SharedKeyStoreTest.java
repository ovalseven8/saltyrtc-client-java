/*
 * Copyright (c) 2016-2018 Threema GmbH
 *
 * Licensed under the Apache License, Version 2.0, <see LICENSE-APACHE file>
 * or the MIT license <see LICENSE-MIT file>, at your option. This file may not be
 * copied, modified, or distributed except according to those terms.
 */

package org.saltyrtc.client.tests.keystore;

import org.junit.Test;
import org.saltyrtc.client.crypto.CryptoException;
import org.saltyrtc.client.crypto.CryptoProvider;
import org.saltyrtc.client.crypto.JnaclCryptoProvider;
import org.saltyrtc.client.exceptions.InvalidKeyException;
import org.saltyrtc.client.keystore.Box;
import org.saltyrtc.client.keystore.KeyStore;
import org.saltyrtc.client.keystore.SharedKeyStore;

import java.security.SecureRandom;

import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertEquals;

public class SharedKeyStoreTest {

    private SecureRandom random = new SecureRandom();
    private CryptoProvider cryptoProvider = new JnaclCryptoProvider();

    @Test
    public void testEncrypt() throws CryptoException, InvalidKeyException {
        // Plaintext
        final byte[] in = "hello".getBytes();

        // Classic KeyStore
        final KeyStore ks = new KeyStore(this.cryptoProvider);

        // Nonce
        final byte[] nonce = new byte[CryptoProvider.NONCEBYTES];
        this.random.nextBytes(nonce);

        // Peer public key
        final byte[] otherKey = new byte[CryptoProvider.PUBLICKEYBYTES];
        this.random.nextBytes(otherKey);

        // Create shared keystore
        final SharedKeyStore sks = new SharedKeyStore(this.cryptoProvider, ks.getPrivateKey(), otherKey);

        // Encrypt and compare
        final Box encryptedKs = ks.encrypt(in, nonce, otherKey);
        final Box encryptedSks = sks.encrypt(in, nonce);
        assertEquals(encryptedKs, encryptedSks);
    }

    @Test
    public void testDecrypt() throws CryptoException, InvalidKeyException {
        // The following values have been generated by logging the values in the KeyStore encrypt test.
        final byte[] privateKey = {98, -128, 32, -16, -93, -3, 90, -19, -62, -45, -89, -120, 0, 54, -31, -52, -88, 83, -51, -7, 84, 60, 101, 94, 33, 21, -57, 7, 51, 5, 61, 34};
        final byte[] nonce = {110, -111, 24, -87, 127, 91, 87, -121, 119, 13, -23, 14, -88, -12, -30, -73, -88, -112, -65, -76, -73, -11, 64, 37};
        final byte[] otherKey = {34, 81, 26, 50, -112, 8, -78, -80, 76, -66, -91, 31, 122, -98, 102, -24, -56, -40, -2, -115, -110, -23, 95, 47, 51, 25, 77, 59, 59, -11, -120, 100};
        final byte[] encrypted = {-39, -59, 107, -111, -84, 49, 71, -67, 63, -28, -94, 40, 48, 121, 68, -40, 63, 102, 9, 90, 97};
        final Box box = new Box(nonce, encrypted);

        // Decrypt with SharedKeyStore
        final SharedKeyStore sks = new SharedKeyStore(this.cryptoProvider, privateKey, otherKey);
        final byte[] decryptedSks = sks.decrypt(box);
        assertArrayEquals("hello".getBytes(), decryptedSks);
    }
}
